# [우테코 - 로또미션]

---

- 멤버 변수와 지역 변수의 개념이 헷갈려서 다시 찾아보았다
    - 멤버 변수(member variable)
        - 메소드 밖에서 선언된 변수 (선언위치가 ‘클래스 영역’)
        - 다시 두 가지로 나누어짐
            - 클래스 변수
                - 모든 객체가 공통적으로 똑같은 속성을 가질 때 클래스 변수 선언
            - 인스턴스 변수
                - 각각의 객체(인스턴스)마다 개별적인 속성을 가져야 할 때 인스턴스 변수 선언

                ```jsx
                //예시
                - 모든 게임 캐릭터는 1m의 키를 동일하게 갖도록 고정
                - 머리 색깔은 선택할 수 있음 -> 모든 캐릭터마다 다른 값을 가질 수 있음
                
                즉, 
                바꿀 수 없는 키 => 클래스 변수
                바꿀 수 있는 머리색 => 인스턴스 변수
                
                class createCharacter {
                	static int height = 100;  // 클래스 변수
                	String hairColor; // 인스턴스 변수
                
                ```

    - 지역 변수(local variable)
        - 메소드 안에서 선언된 변수 (선언위치가 ‘메소드나 생성자 내부’)
- 일급 컬렉션
    - Collection을 Wrapping하면서, 그 외 다른 멤버 변수가 없는 상태

    ```jsx
    Map<String, String> map = new HashMap<>();
    map.put("1", "A");
    map.put("2", "B");
    map.put("3", "C");
    ```

  위의 코드를 아래와 같이 Wrapping 하는 것을 의미

    ```jsx
    public class GameRanking {
    
        private Map<String, String> ranks;
    
        public GameRanking(Map<String, String> ranks) {
            this.ranks = ranks;
        }
    }
    ```

    - 일급 컬렉션을 사용하면 상태와 로직을 따로 관리할 수 있기 때문에 로직이 사용되는 클래스의 부담을 줄일 수 있고, 중복코드를 줄일 수 있다.

- Enum이란?
    - enumerance type = 열거형
    - 비교 시 실제 값 뿐만 아니라 타입까지 체크 가능
    - 상수값이 재정의 되어도 다시 컴파일 할 필요 X

    ```jsx
    enum Color {
    	RED, YELLOW, GREEN, BLUE
    }
    
    //위와 같이 정의하고 **Color.RED** 와 같이 사용
    ```

- 그렇다면 EnumMap이란?
    - Enum 타입만 key로 사용 가능한 특별한 Map
    - Array를 이용하기 때문에 성능적으로 우수
    - 해싱 과정이 필요 없어 HashMap 보다 빠름
    - null을 key로 넣는 경우 NullPointerException 발생
        - key에 들어갈 값을 생성 시 정의하기 때문에 Enum 타입 외에는 key로 만들 수 없다 (null을 key로 만드는 것도 막음)

- 해야 할 일
    1. 추첨 결과 출력
        - 수익률 출력 (수익률 = 당첨 금액 / 구입 금액)
    2. 추첨
        - 숫자랑 위치 일치하는지 확인
        - 보너스볼 확인
    3. 보너스 번호 입력
        - 숫자는 1 ~ 45
        - (error) 당첨 번호와 중복 불가
    4. 당첨 번호 입력
        - 6개 숫자 입력 (ex: 1, 2, 3)
        - 숫자는 1 ~ 45
        - 입력 구분자는 ,
        - (error) 중복된 숫자 불가
    5. 로또 목록
        - 로또 생성
            - 숫자는 1 ~ 45
            - (error) 중복된 숫자 불가
            - Collections.shuffle() 활용
        - 목록 출력
        - 로또 숫자 정렬
    6. 구매한 로또 개수 출력
    7. 로또 구입 금액
        - 로또 가격은 1000원
        - (error) 1000원 단위 외의 금액 불가
        - (error) 문자열 입력
        - 구매 로또 개수 구하기 (입력받은 금액 / 1000)
- 기능별로 세세하게 나눠보기
    - [ ]  구입금액 입력받기
        - [x]  구입금액 / 1000 → 로또 몇 장 구매했는지 출력하기
    - **로또 발행**
        - [x]  1 - 45 사이의 중복되지 않는 6개의 숫자 뽑기
        - [x]  발행한 로또 오름차순 정렬
        - [x]  발행한 로또 저장 및 출력하기
    - 당첨 번호, 보너스 번호 입력받기
        - [x]  당첨 번호 입력받기
        - [x]  보너스 번호 입력받기
    - 로또 결과 판단
        - [ ]  사용자가 구매한 로또 번호 6개와 보너스 번호 비교
            - [ ]  일치하는 번호의 개수 구하기
        - [ ]  등수 판단
            - [ ]  6개 번호 일치 → 1등
            - [ ]  5개 번호 일치하면 로또 번호 6개와 보너스번호 1개 비교
                - [ ]  로또 번호와 보너스 번호 일치 → 2등
                - [ ]  로또 번호와 보너스 번호 일치 X → 3등
            - [ ]  4개 번호 일치 → 4등
            - [ ]  3개 번호 일치 → 5등
    - 결과 출력
        - [ ]  당첨 내역 출력
    - 수익률 계산
        - [ ]  수익률 계산
        - [ ]  수익률 출력
    - 예외처리
        - [x]  로또 구입 금액이 1000원으로 나누어 떨어지지 않는 경우
        - [x]  로또 구입 금액이 정수가 아닌 경우
        - [x]  (사용자) 입력한 로또 번호가 6개가 아닌 경우
        - [ ]  (사용자) 입력한 로또 번호가 1 - 45 사이의 수가 아닌 경우
        - [ ]  (사용자) 입력한 로또 번호가 중복되는 경우
        - [x]  (사용자) 입력한 로또 번호가 정수가 아닌 경우
        - [x]  보너스 번호가 정수가 아닌 경우
        - [ ]  보너스 번호가 1 - 45 사이의 수가 아닌 경우
        - [ ]  보너스 번호가 입력한 로또번호와 중복되는 경우
    - 게임 종료
        - [ ]  로또 게임 종료
- 구현하면서 고민했던 부분
    - 하나의 클래스가 하나의 책임을 가지도록 하고 싶은데 어디까지 쪼개고 나눠야 할 지 감이 잘 안 잡힌다.
        - 예를 들면, 로또 금액 입력받는 클래스, 발행된 로또들을 관리하는 클래스 같이 하나하나 쪼개면 너무 클래스들이 많아질 것 같아 고민이 된다..
    - LottoManager와 LottoGenerator의 책임 분리가 조금 어려웠다. 로또 숫자 생성과 저장 및 관리를 같이하게 되면 단일책임의 원칙에 어긋날 것 같아 클래스를 분리해봤는데, 또 한편으로는 비슷한 기능이라 하나의 클래스 내에서 메소드로 구현해도 괜찮지 않을까 하는 생각도 들었다.
    - WARNING: An illegal reflective access operation has occurred 이란 경고문구 발생
        - **--illegal-access=deny 이라는 jvm 옵션을 추가해 일단은 경고문구가 뜨지 않게 했으나,
          unable to determine if the scanner is closed.**

          이라는 경고문구가 다시 추가되었다.. 라이브러리의 업데이트를 받아와야 하는지,, 일단은 프로그램 정상 동작이 최우선 목표이기에 넘어갔다.

    - LottoGenerator 클래스의 generateLotto메서드에서 구매한 로또 장 수 만큼 로또를 발행하게끔 구현했는데, 후에 이를 Lottomanager클래스에서 발행된 로또를 관리하게끔 메서드를 끌어와 사용하다보니 에러가 발생했다.. 너무 클래스간 관계가 복잡해진것 같다..
    - 또한 LottoResult 부분은 로또 당첨번호와 구입한 번호들을 비교하여 통계를 내는 마지막 단계인데, 워낙 클래스도 많고 비슷한 변수도 많다보니 결국 꼬여버린 것 같다. 어떻게든 동작되게끔 하려 했지만 그보다는 다시 클래스간 관계를 정의하고 정리된 상태에서 다시 코드를 짜보는게 맞는 것 같다는 생각을 했다.